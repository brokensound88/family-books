# Backend Structure Document for FamilyBooks

## **Overview**

**FamilyBooks** is an iOS-first mobile application designed to empower families to manage their finances, synchronize bank accounts, superannuation (with a focus on the Australian market), savings, and investment accounts, educate children on saving and investing, and balance household budgets through a visually stunning, gamified interface. The backend is built using **Kotlin Multiplatform Mobile (KMM)** for shared business logic, integrated with **SwiftUI** for the iOS frontend, and designed for future Android expansion using Jetpack Compose. Development leverages **Windsurf** (IntelliJ-based IDE) and **Cursor** (AI-driven IDE) for vibe-coding, utilizing AI-assisted tools like GitHub Copilot to streamline code generation. This Backend Structure Document outlines the architecture, components, APIs, data models, security measures, and vibe-coding workflows required to support the app’s functionality, ensuring scalability, security, and seamless integration with financial services like Plaid, Yodlee, and FinanceKit. The backend is designed to handle real-time data syncing, AI-driven transaction categorization, and family collaboration features while complying with PCI DSS, GDPR, and Australia’s Privacy Act.

## **Objectives**

- Deliver a robust, scalable backend using KMM to support iOS MVP and future Android expansion.
- Ensure secure integration with financial APIs (Plaid, Yodlee) for account syncing and transaction data.
- Implement cloud-based AI (AWS SageMaker) for transaction categorization, with optional Core ML for iOS offline processing.
- Support real-time family collaboration and notifications via Firebase.
- Achieve 99.9% backend uptime and handle 10,000 concurrent users, scaling to 100,000 within two years.
- Leverage Windsurf and Cursor for AI-assisted vibe-coding to accelerate backend development.

## **Backend Scope**

### **MVP Backend Features**

The backend, implemented in KMM, supports the following functionalities for the iOS MVP:

1. **Financial Account Integration**:
   - Sync with bank accounts, superannuation, savings, and investments via Plaid/Yodlee.
   - Process manual CSV imports for unsupported accounts.
2. **Budgeting and Bookkeeping**:
   - Manage zero-based budgets with customizable categories.
   - AI-driven transaction categorization using AWS SageMaker.
   - Store and retrieve transaction and budget data in Firestore.
3. **Kids’ Education Module**:
   - Track savings goals and virtual portfolios for kids.
   - Handle parental oversight logic (e.g., goal approvals).
4. **Analytics and Insights**:
   - Calculate net worth and financial health scores.
   - Generate spending patterns for frontend visualizations.
5. **Investment and Savings**:
   - Sync and process portfolio and superannuation data.
   - Provide AI-driven savings suggestions.
6. **Family Collaboration**:
   - Manage family accounts with role-based access (admin for parents, limited for kids).
   - Support shared goals with real-time updates.
7. **Notifications**:
   - Send push notifications for bill reminders and goal updates via Firebase Cloud Messaging.

### **Future Backend Features (Post-MVP)**

- Android support with Jetpack Compose, reusing KMM logic.
- Advanced investment analytics (e.g., robo-advisory, crypto tracking).
- Web API for future desktop app.
- Enhanced AI models for personalized financial advice.

## **Backend Architecture**

### **Architecture Overview**

- **Type**: Serverless backend with KMM for shared logic, integrated with cloud services (Firebase, AWS).
- **Components**:
  - **KMM Shared Module**: Kotlin-based logic for API clients, data models, and business rules, reusable across iOS and Android.
  - **Firebase**: Authentication, Firestore for real-time data, Cloud Messaging for notifications.
  - **AWS**: SageMaker for AI-driven transaction categorization, EC2/S3 for hosting and storage.
  - **External APIs**: Plaid/Yodlee for financial data, Stripe for payments.
- **Data Flow**:
  1. Frontend (SwiftUI) requests data via KMM interfaces.
  2. KMM module interacts with Firebase/AWS and external APIs.
  3. Processed data (e.g., categorized transactions) is returned to SwiftUI for display.

### **KMM Structure**

- **Modules**:
  - `data`: Data models and API clients.
  - `domain`: Business logic (e.g., budget calculations, AI categorization).
  - `platform`: Platform-specific implementations (e.g., iOS Keychain, Android Keystore later).
- **Expect/Actual Mechanism**:

  ```kotlin
  expect interface TransactionRepository {
      suspend fun fetchTransactions(accountId: String): List<Transaction>
  }
  actual class TransactionRepositoryImpl : TransactionRepository {
      actual suspend fun fetchTransactions(accountId: String): List<Transaction> {
          val response = PlaidApi.getTransactions(accountId)
          return response.map { it.toTransaction() }
      }
  }
  ```

## **Data Models**

### **Core Models**

- **User**:

  ```kotlin
  data class User(
      val id: String,
      val email: String,
      val role: Role,
      val familyId: String
  )
  enum class Role { ADMIN, CHILD }
  ```

- **Transaction**:

  ```kotlin
  data class Transaction(
      val id: String,
      val accountId: String,
      val amount: Double,
      val date: String,
      val description: String,
      val category: String? = null
  )
  ```

- **Budget**:

  ```kotlin
  data class Budget(
      val id: String,
      val familyId: String,
      val name: String,
      val amount: Double,
      val spent: Double
  )
  ```

- **Savings Goal**:

  ```kotlin
  data class SavingsGoal(
      val id: String,
      val userId: String,
      val name: String,
      val target: Double,
      val current: Double,
      val approved: Boolean = false
  )
  ```

- **Portfolio**:

  ```kotlin
  data class Portfolio(
      val accountId: String,
      val holdings: List<Holding>,
      val totalValue: Double
  )
  data class Holding(val symbol: String, val value: Double)
  ```

### **Database Schema**

- **Firestore Collections**:
  - `users`: Stores user profiles (id, email, role, familyId).
  - `transactions`: Stores transaction data (id, accountId, amount, date, description, category).
  - `budgets`: Stores budget data (id, familyId, name, amount, spent).
  - `savings_goals`: Stores kids’ goals (id, userId, name, target, current, approved).
  - `portfolios`: Stores investment data (accountId, holdings, totalValue).

## **API Integrations**

### **Plaid/Yodlee**

- **Purpose**: Sync bank accounts, superannuation, savings, and investments.
- **KMM Implementation**:

  ```kotlin
  class PlaidClient {
      suspend fun authenticate(credentials: AccountCredentials): String {
          return PlaidApi.authenticate(credentials).accessToken
      }
      suspend fun getTransactions(accountId: String): List<Transaction> {
          val response = PlaidApi.getTransactions(accountId)
          return response.map { Transaction(id = it.id, amount = it.amount, date = it.date, description = it.description) }
      }
  }
  ```

- **Error Handling**: Retry logic for network failures, fallback to cached data.

### **Firebase**

- **Authentication**:

  ```kotlin
  class AuthService {
      suspend fun signIn(email: String, password: String): User {
          return FirebaseAuth.signIn(email, password).toUser()
      }
      suspend fun signUp(email: String, role: Role): User {
          return FirebaseAuth.createUser(email, role).toUser()
      }
  }
  ```

- **Firestore**:

  ```kotlin
  class FirestoreClient {
      suspend fun saveBudget(budget: Budget): Budget {
          Firestore.collection("budgets").document(budget.id).set(budget)
          return budget
      }
      suspend fun getTransactions(familyId: String): List<Transaction> {
          return Firestore.collection("transactions").whereEqualTo("familyId", familyId).get().toTransactions()
      }
  }
  ```

- **Cloud Messaging**:

  ```kotlin
  class NotificationService {
      suspend fun sendNotification(userId: String, message: String) {
          FirebaseMessaging.send(userId, message)
      }
  }
  ```

### **AWS SageMaker**

- **Purpose**: AI-driven transaction categorization.
- **Implementation**:

  ```kotlin
  class Categorizer {
      suspend fun categorize(transactions: List<Transaction>): List<Transaction> {
          val response = SageMakerClient.invokeEndpoint(transactions.map { it.description })
          return transactions.mapIndexed { index, tx ->
              tx.copy(category = response[index].category)
          }
      }
  }
  ```

### **Stripe**

- **Purpose**: Handle premium subscriptions and family plans.
- **Implementation**:

  ```kotlin
  class PaymentService {
      suspend fun createSubscription(userId: String, plan: String): Subscription {
          return StripeApi.createSubscription(userId, plan)
      }
  }
  ```

## **Security Requirements**

- **Encryption**:
  - End-to-end encryption for API calls using HTTPS and TLS 1.3.
  - Encrypt sensitive data (e.g., account tokens) in Firestore:

    ```kotlin
    fun encryptData(data: String): String {
        return EncryptionUtil.encrypt(data, key = "secureKey")
    }
    ```

- **Authentication**:
  - Multi-factor authentication (MFA) via Firebase.
  - Secure credential storage using iOS Keychain (SwiftUI integration):

    ```swift
    import Security
    func saveToken(token: String) {
        let data = token.data(using: .utf8)!
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: "userToken",
            kSecValueData as String: data
        ]
        SecItemAdd(query as CFDictionary, nil)
    }
    ```

- **Compliance**:
  - PCI DSS for payment processing (via Stripe).
  - GDPR for user data protection (e.g., right to delete).
  - Australia’s Privacy Act for local compliance.
- **Access Control**:
  - Role-based access in KMM (admin for parents, limited for kids):

    ```kotlin
    fun restrictAccess(user: User, action: Action): Boolean {
        return user.role == Role.ADMIN || action.isChildAllowed
    }
    ```

## **Performance Requirements**

- **Scalability**: Handle 10,000 concurrent users, scaling to 100,000 within two years using Firestore’s auto-scaling.
- **Latency**:
  - API responses within 500ms under normal conditions.
  - Transaction syncing within 5 seconds.
- **Uptime**: Achieve 99.9% availability via Firebase/AWS.
- **Caching**:
  - Cache recent transactions locally for offline access:

    ```kotlin
    class CacheManager {
        suspend fun cacheTransactions(transactions: List<Transaction>) {
            LocalStorage.save("transactions", transactions)
        }
        suspend fun getCachedTransactions(): List<Transaction> {
            return LocalStorage.get("transactions") ?: emptyList()
        }
    }
    ```

## **Vibe-Coding Workflow**

### **Tools**

- **Windsurf**: IntelliJ-based IDE for KMM development, with Copilot for Kotlin code completion.
- **Cursor**: AI-driven IDE for SwiftUI integration and debugging, with prompts for KMM logic.
- **AWS Console**: Configure SageMaker and EC2/S3.
- **Firebase Console**: Manage authentication, Firestore, and notifications.

### **Development Process**

1. **Setup** (1–2 weeks):
   - Initialize KMM project in Windsurf:

     ```kotlin
     // Create a KMM module with data, domain, and platform packages
     ```

   - Configure Firebase and AWS in Windsurf’s build.gradle.kts.
2. **Data Models and Repositories** (3–4 weeks):
   - Define models (e.g., Transaction, Budget) in KMM:

     ```kotlin
     data class Transaction(val id: String, val amount: Double, val date: String, val description: String)
     ```

   - Implement repositories for Plaid/Yodlee, Firestore:

     ```kotlin
     expect interface BudgetRepository {
         suspend fun createBudget(name: String, amount: Double): Budget
     }
     actual class BudgetRepositoryImpl : BudgetRepository {
         actual suspend fun createBudget(name: String, amount: Double): Budget {
             val budget = Budget(id = UUID.randomUUID().toString(), familyId = "family123", name, amount, spent = 0.0)
             Firestore.collection("budgets").document(budget.id).set(budget)
             return budget
         }
     }
     ```

   - Use Cursor prompts:

     ```kotlin
     // Generate a Kotlin repository for fetching transactions from Plaid
     ```

3. **AI Integration** (2–3 weeks):
   - Configure SageMaker endpoint for categorization:

     ```kotlin
     class SageMakerClient {
         suspend fun categorizeTransactions(transactions: List<Transaction>): List<String> {
             return AwsSageMaker.invokeEndpoint(transactions.map { it.description })
         }
     }
     ```

   - Test AI accuracy with sample transactions.
4. **Authentication and Notifications** (2 weeks):
   - Implement Firebase auth and notifications:

     ```kotlin
     class NotificationService {
         suspend fun sendBillReminder(userId: String, bill: Bill) {
             FirebaseMessaging.send(userId, "Bill due: ${bill.name} on ${bill.dueDate}")
         }
     }
     ```

5. **Security Implementation** (2 weeks):
   - Add encryption and access control in KMM.
   - Test MFA and Keychain integration in Cursor.

### **Vibe-Coding Integration**

- **Windsurf**:
  - Use Copilot for rapid KMM development:

    ```kotlin
    // Create a Kotlin function to sync superannuation data with Yodlee
    ```

  - Leverage IntelliJ’s KMM templates for repository scaffolding.
- **Cursor**:
  - Generate SwiftUI-KMM integration code:

    ```swift
    // Integrate KMM TransactionRepository with SwiftUI view model
    ```

  - Debug API errors with AI suggestions.
- **Iterative Development**:
  - Code in 1–2 week sprints (e.g., Plaid integration, Firestore setup).
  - Validate with mock data in Windsurf’s KMM simulator.

## **Testing Requirements**

- **Unit Testing**:
  - Test KMM logic with JUnit:

    ```kotlin
    @Test
    fun testTransactionFetch() = runTest {
        val repo = TransactionRepositoryImpl()
        val transactions = repo.fetchTransactions("account123")
        assertEquals(2, transactions.size)
    }
    ```

- **Integration Testing**:
  - Verify Plaid/Yodlee, Firebase, and SageMaker integrations.
- **Security Testing**:
  - Conduct penetration testing for API vulnerabilities.
- **Load Testing**:
  - Simulate 1,000 concurrent users to ensure scalability.

## **Constraints**

- **API Coverage**: Some Australian super funds may not support Plaid/Yodlee, requiring manual imports.
- **Cost**: API subscriptions (Plaid: $500–$5,000/month, Firebase: $500–$2,000/month).
- **Compliance**: Must meet PCI DSS, GDPR, and Australia’s Privacy Act, adding development time.

## **Dependencies**

- **Firebase**: Authentication, Firestore, Cloud Messaging.
- **AWS**: SageMaker, EC2/S3.
- **Plaid/Yodlee**: Financial data syncing.
- **Stripe**: Payment processing.
- **Windsurf/Cursor**: Development IDEs with Copilot.

## **Success Criteria**

- **Functionality**: All MVP backend features (syncing, budgeting, AI, collaboration) operational.
- **Performance**: API responses in <500ms, syncing in <5 seconds.
- **Scalability**: Handles 10,000 concurrent users without downtime.
- **Security**: No critical vulnerabilities in penetration testing.
- **Reusability**: 40–50% KMM logic reusable for Android.

## **Conclusion**

This Backend Structure Document provides a comprehensive blueprint for building the **FamilyBooks** backend using KMM, ensuring scalability, security, and integration with financial APIs. By leveraging Windsurf and Cursor for vibe-coding, with AI tools accelerating development, the backend will support a robust iOS MVP and future Android expansion. The architecture balances performance, compliance, and family-focused functionality, setting the stage for a successful app launch.

*Word Count: ~2000*

```

---
