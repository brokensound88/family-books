# System Prompts for FamilyBooks

## **Overview**

**FamilyBooks** is an iOS-first mobile application designed to empower families to manage their finances, synchronize bank accounts, superannuation (with a focus on the Australian market), savings, and investment accounts, educate children on saving and investing, and balance household budgets through a visually stunning, gamified interface. The app leverages **Kotlin Multiplatform Mobile (KMM)** for shared business logic and **SwiftUI** for the iOS frontend, with plans for future Android expansion using Jetpack Compose. Development is driven by **Windsurf** (IntelliJ-based IDE) and **Cursor** (AI-driven IDE) for vibe-coding, utilizing AI-assisted tools like GitHub Copilot and Figma plugins (Magician, Builder.io) to accelerate wireframing, code generation, and debugging. This System Prompts Document provides a comprehensive set of AI prompts for use in Windsurf, Cursor, and Figma to streamline the development process, covering frontend (SwiftUI), backend (KMM), and UI design. The prompts are tailored to ensure a visually stunning, family-focused app with seamless financial integrations (Plaid, Yodlee, FinanceKit) and kid-friendly educational features, while maintaining accessibility, performance, and compliance with PCI DSS, GDPR, and Australia’s Privacy Act. The prompts are designed for rapid prototyping, iterative coding, and user validation, aligning with the vibe-coding philosophy.

## **Objectives**

- Provide precise, reusable AI prompts for Windsurf (Kotlin/KMM), Cursor (SwiftUI), and Figma (Magician/Builder.io) to accelerate development.
- Ensure prompts generate code and designs that align with the app’s goals: intuitive financial management, kid-friendly gamification, and vibrant SwiftUI interfaces.
- Support integration with KMM backend logic and financial APIs (Plaid, Yodlee, FinanceKit).
- Enable rapid prototyping and user validation of UI/UX flows.
- Facilitate scalable development for future Android implementation with Jetpack Compose.
- Achieve a 4.5+ App Store rating through engaging, AI-assisted UX development.

## **Prompt Scope**

The prompts are organized by development area: **UI Design (Figma)**, **Frontend (SwiftUI)**, **Backend (KMM)**, and **Testing/Debugging**. Each section includes specific prompts for generating wireframes, code, and tests, with examples of expected outputs. The prompts are designed for use in Windsurf (via Copilot), Cursor (AI-driven coding), and Figma (Magician/Builder.io), ensuring compatibility with the app’s tech stack and vibe-coding workflow.

### **MVP Prompt Areas**

1. **UI Design (Figma)**: Wireframes and prototypes for dashboard, budgeting, kids’ education, investments, and settings.
2. **Frontend (SwiftUI)**: Views for dashboards, budgets, kids’ modules, investments, and family collaboration, with animations and accessibility.
3. **Backend (KMM)**: Data models, API clients, and AI logic for financial syncing, budgeting, and goal tracking.
4. **Testing/Debugging**: Unit tests, UI tests, and debugging prompts for KMM and SwiftUI.

### **Future Prompt Areas (Post-MVP)**

- Android UI (Jetpack Compose) prompts.
- Advanced AI feature prompts (e.g., robo-advisory).
- Web app API prompts.

## **UI Design Prompts (Figma with Magician/Builder.io)**

### **Purpose**

Generate wireframes and prototypes for the iOS app, ensuring a visually stunning, family-friendly UI with gamified elements and iOS Human Interface Guidelines compliance.

### **Prompts**

1. **Dashboard Wireframe**:
   - **Prompt**: “Create an iOS wireframe for a family finance dashboard with a colorful net worth chart, budget overview cards, and a quick link to kids’ savings goals. Use vibrant gradients (blue, green), SF Symbols, and a clean layout adhering to iOS Human Interface Guidelines. Include accessibility features like dynamic type support.”
   - **Expected Output**: Figma layout with a `Chart` view, card-based budget summaries, and a navigation bar, exportable to SwiftUI via Builder.io.
   - **Usage**: Input into Magician, refine in Figma, export to SwiftUI:

     ```swift
     struct DashboardView: View {
         var body: some View {
             NavigationStack {
                 ScrollView {
                     VStack {
                         Chart { /* Placeholder for spending data */ }
                             .frame(height: 200)
                             .foregroundStyle(.blue.gradient)
                         Text("Net Worth: $10,000")
                             .font(.title)
                             .dynamicTypeSize(.large)
                     }
                 }
                 .navigationTitle("Family Wealth")
             }
         }
     }
     ```

2. **Kids’ Education Wireframe**:
   - **Prompt**: “Design an iOS wireframe for a kids’ financial education screen with animated savings jars, a virtual stock portfolio, and parental approval buttons. Use vibrant colors (green, yellow), large buttons for kids (ages 8–18), and SF Symbols. Ensure VoiceOver compatibility.”
   - **Expected Output**: Figma prototype with circular progress bars and interactive buttons, exportable to SwiftUI.
3. **Budget Screen Wireframe**:
   - **Prompt**: “Generate an iOS wireframe for a budgeting screen with a list of customizable categories, progress bars for spending, and a form to create new budgets. Use a clean, family-friendly design with blue gradients and SF Symbols.”
   - **Expected Output**: Figma layout with a `List` view and form, exportable to SwiftUI.
4. **Investment Tracking Wireframe**:
   - **Prompt**: “Create an iOS wireframe for an investment tracking screen showing portfolio performance with a line chart, superannuation balance, and savings suggestions. Use purple gradients and iOS-native typography.”
   - **Expected Output**: Figma chart-based layout, exportable to SwiftUI.
5. **Settings Wireframe**:
   - **Prompt**: “Design an iOS settings wireframe with sections for account management, theme selection (blue, pastel), and notification preferences. Ensure accessibility with high-contrast options.”
   - **Expected Output**: Figma form-based layout, exportable to SwiftUI.

### **Usage Guidelines**

- **Magician**: Input prompts to generate initial wireframes, refine manually in Figma.
- **Builder.io**: Export designs to SwiftUI code, then refine in Cursor.
- **Validation**: Test prototypes with 10–20 families to ensure intuitive UX.

## **Frontend Prompts (SwiftUI in Cursor)**

### **Purpose**

Generate SwiftUI views for the iOS app, integrating with KMM backend logic, with vibrant animations, accessibility, and iOS-native performance.

### **Prompts**

1. **Dashboard View**:
   - **Prompt**: “Create a SwiftUI view for a family finance dashboard with an animated bar chart for spending by category, a net worth display, and navigation links to budgets and kids’ goals. Use vibrant blue gradients, SF Symbols, and accessibility features (VoiceOver, dynamic type). Integrate with a KMM TransactionRepository for data.”
   - **Expected Output**:

     ```swift
     import shared
     struct DashboardView: View {
         @StateObject private var viewModel = DashboardViewModel()
         var body: some View {
             NavigationStack {
                 ScrollView {
                     VStack {
                         Chart {
                             ForEach(viewModel.spendingData) { data in
                                 BarMark(x: .value("Category", data.category), y: .value("Amount", data.amount))
                                     .foregroundStyle(.blue.gradient)
                             }
                         }
                         .frame(height: 200)
                         .animation(.easeInOut, value: viewModel.spendingData)
                         .accessibilityLabel("Spending by category chart")
                         Text("Net Worth: $\(viewModel.netWorth, specifier: "%.2f")")
                             .font(.title)
                             .dynamicTypeSize(.large)
                             .accessibilityLabel("Net worth: \(viewModel.netWorth, specifier: "%.2f") dollars")
                         NavigationLink("Budgets", destination: BudgetView())
                         NavigationLink("Kids’ Goals", destination: KidsView())
                     }
                     .padding()
                 }
                 .navigationTitle("Family Wealth")
                 .task { await viewModel.loadData() }
             }
         }
     }
     class DashboardViewModel: ObservableObject {
         @Published var netWorth: Double = 0.0
         @Published var spendingData: [CategoryData] = []
         private let repository: TransactionRepository = TransactionRepositoryImpl()
         func loadData() async {
             let transactions = try! await repository.fetchTransactions(accountId: "user123").toList()
             netWorth = transactions.reduce(0.0) { $0 + $1.amount }
             spendingData = transactions.groupByCategory()
         }
     }
     ```

2. **Budget Creation View**:
   - **Prompt**: “Generate a SwiftUI view for creating a zero-based budget with a form for name and amount, using a blue gradient button and accessibility support. Integrate with a KMM BudgetRepository.”
   - **Expected Output**:

     ```swift
     struct NewBudgetView: View {
         @StateObject private var viewModel = BudgetViewModel()
         @Environment(\.dismiss) private var dismiss
         var body: some View {
             Form {
                 TextField("Budget Name", text: $viewModel.name)
                     .accessibilityLabel("Enter budget name")
                 TextField("Amount", value: $viewModel.amount, format: .currency(code: "AUD"))
                     .keyboardType(.decimalPad)
                     .accessibilityLabel("Enter budget amount in Australian dollars")
                 Button("Save") {
                     Task { await viewModel.saveBudget() }
                     dismiss()
                 }
                 .buttonStyle(.borderedProminent)
                 .tint(.blue)
                 .accessibilityLabel("Save budget")
             }
             .navigationTitle("New Budget")
         }
     }
     class BudgetViewModel: ObservableObject {
         @Published var name: String = ""
         @Published var amount: Double = 0.0
         private let repository: BudgetRepository = BudgetRepositoryImpl()
         func saveBudget() async {
             let budget = try! await repository.createBudget(name: name, amount: amount)
         }
     }
     ```

3. **Kids’ Savings Goal View**:
   - **Prompt**: “Create a SwiftUI view for a kids’ savings goal with an animated circular progress bar, vibrant green colors, and gamified elements (e.g., confetti on completion). Include VoiceOver support and integrate with a KMM SavingsGoalRepository.”
   - **Expected Output**:

     ```swift
     struct SavingsJarView: View {
         @StateObject private var viewModel = SavingsJarViewModel()
         @State private var showConfetti = false
         var body: some View {
             VStack {
                 Text(viewModel.goalName)
                     .font(.title2)
                     .dynamicTypeSize(.large)
                 ProgressView(value: viewModel.progress)
                     .progressViewStyle(.circular)
                     .tint(.green)
                     .scaleEffect(1.5)
                     .animation(.spring(), value: viewModel.progress)
                     .accessibilityLabel("Goal: \(viewModel.goalName), \(Int(viewModel.progress * 100))% complete")
                 if showConfetti {
                     ConfettiView() // Custom view for confetti animation
                 }
             }
             .padding()
             .task {
                 await viewModel.loadGoal()
                 if viewModel.progress >= 1.0 { showConfetti = true }
             }
         }
     }
     class SavingsJarViewModel: ObservableObject {
         @Published var goalName: String = ""
         @Published var progress: Double = 0.0
         private let repository: SavingsGoalRepository = SavingsGoalRepositoryImpl()
         func loadGoal() async {
             let goal = try! await repository.getGoal(goalId: "goal123")
             goalName = goal.name
             progress = goal.current / goal.target
         }
     }
     ```

4. **Investment Tracking View**:
   - **Prompt**: “Generate a SwiftUI view for investment tracking with a line chart for portfolio performance, superannuation balance, and a purple gradient style. Ensure accessibility and integrate with a KMM PortfolioRepository.”
   - **Expected Output**:

     ```swift
     struct InvestmentsView: View {
         @StateObject private var viewModel = InvestmentsViewModel()
         var body: some View {
             ScrollView {
                 VStack {
                     Chart {
                         ForEach(viewModel.holdings) { holding in
                             LineMark(x: .value("Date", holding.date), y: .value("Value", holding.value))
                                 .foregroundStyle(.purple.gradient)
                         }
                     }
                     .frame(height: 200)
                     .accessibilityLabel("Portfolio performance chart")
                     Text("Portfolio Value: $\(viewModel.totalValue, specifier: "%.2f")")
                         .font(.title)
                         .dynamicTypeSize(.large)
                 }
                 .padding()
             }
             .navigationTitle("Investments")
             .task { await viewModel.loadPortfolio() }
         }
     }
     class InvestmentsViewModel: ObservableObject {
         @Published var holdings: [Holding] = []
         @Published var totalValue: Double = 0.0
         private let repository: PortfolioRepository = PortfolioRepositoryImpl()
         func loadPortfolio() async {
             let portfolio = try! await repository.fetchPortfolio(accountId: "account123")
             holdings = portfolio.holdings
             totalValue = portfolio.totalValue
         }
     }
     ```

### **Usage Guidelines**

- **Cursor**: Input prompts to generate SwiftUI views, refine for performance and accessibility.
- **Windsurf**: Use Copilot to generate KMM integration code for SwiftUI view models.
- **Validation**: Test views in Xcode’s SwiftUI preview and with beta users via TestFlight.

## **Backend Prompts (KMM in Windsurf)**

### **Purpose**

Generate KMM logic for data models, API clients, and AI processing, ensuring seamless integration with SwiftUI and scalability for Android.

### **Prompts**

1. **Transaction Repository**:
   - **Prompt**: “Create a KMM TransactionRepository with expect/actual pattern to fetch and categorize transactions from Plaid, integrating with AWS SageMaker for AI categorization. Include error handling and caching.”
   - **Expected Output**:

     ```kotlin
     expect interface TransactionRepository {
         suspend fun fetchTransactions(accountId: String): List<Transaction>
         suspend fun categorizeTransactions(transactions: List<Transaction>): List<Transaction>
     }
     actual class TransactionRepositoryImpl : TransactionRepository {
         private val plaidClient = PlaidClient()
         private val cache = CacheManager()
         private val categorizer = Categorizer()
         actual suspend fun fetchTransactions(accountId: String): List<Transaction> {
             try {
                 val transactions = plaidClient.getTransactions(accountId)
                 cache.cacheTransactions(transactions)
                 return transactions
             } catch (e: Exception) {
                 return cache.getCachedTransactions()
             }
         }
         actual suspend fun categorizeTransactions(transactions: List<Transaction>): List<Transaction> {
             return categorizer.categorize(transactions)
         }
     }
     data class Transaction(val id: String, val accountId: String, val amount: Double, val date: String, val description: String, val category: String? = null)
     ```

2. **Budget Repository**:
   - **Prompt**: “Generate a KMM BudgetRepository to create and retrieve budgets from Firestore, with support for family-based access control.”
   - **Expected Output**:

     ```kotlin
     expect interface BudgetRepository {
         suspend fun createBudget(familyId: String, name: String, amount: Double): Budget
         suspend fun getBudgets(familyId: String): List<Budget>
     }
     actual class BudgetRepositoryImpl : BudgetRepository {
         actual suspend fun createBudget(familyId: String, name: String, amount: Double): Budget {
             val budget = Budget(id = UUID.randomUUID().toString(), familyId, name, amount, spent = 0.0)
             Firestore.collection("budgets").document(budget.id).set(budget)
             return budget
         }
         actual suspend fun getBudgets(familyId: String): List<Budget> {
             return Firestore.collection("budgets").whereEqualTo("familyId", familyId).get().toBudgets()
         }
     }
     data class Budget(val id: String, val familyId: String, val name: String, val amount: Double, val spent: Double)
     ```

3. **Savings Goal Repository**:
   - **Prompt**: “Create a KMM SavingsGoalRepository to manage kids’ savings goals in Firestore, with parental approval logic.”
   - **Expected Output**:

     ```kotlin
     expect interface SavingsGoalRepository {
         suspend fun createGoal(userId: String, name: String, target: Double): SavingsGoal
         suspend fun approveGoal(goalId: String): SavingsGoal
     }
     actual class SavingsGoalRepositoryImpl : SavingsGoalRepository {
         actual suspend fun createGoal(userId: String, name: String, target: Double): SavingsGoal {
             val goal = SavingsGoal(id = UUID.randomUUID().toString(), userId, name, target, current = 0.0, approved = false)
             Firestore.collection("savings_goals").document(goal.id).set(goal)
             return goal
         }
         actual suspend fun approveGoal(goalId: String): SavingsGoal {
             val goal = Firestore.collection("savings_goals").document(goalId).get().toGoal().copy(approved = true)
             Firestore.collection("savings_goals").document(goalId).set(goal)
             return goal
         }
     }
     data class SavingsGoal(val id: String, val userId: String, val name: String, val target: Double, val current: Double, val approved: Boolean)
     ```

4. **AI Categorization**:
   - **Prompt**: “Generate a KMM function to categorize transactions using AWS SageMaker, with error handling and fallback to default categories.”
   - **Expected Output**:

     ```kotlin
     class Categorizer {
         suspend fun categorize(transactions: List<Transaction>): List<Transaction> {
             try {
                 val response = SageMakerClient.invokeEndpoint(transactions.map { it.description })
                 return transactions.mapIndexed { index, tx ->
                     tx.copy(category = response[index].category)
                 }
             } catch (e: Exception) {
                 return transactions.map { it.copy(category = "Uncategorized") }
             }
         }
     }
     ```

### **Usage Guidelines**

- **Windsurf**: Input prompts into Copilot for KMM code generation, test in IntelliJ’s KMM simulator.
- **Cursor**: Use prompts to generate SwiftUI-KMM integration code.
- **Validation**: Test API integrations with Postman and mock data.

## **Testing/Debugging Prompts**

### **Purpose**

Generate test cases and debug issues in KMM and SwiftUI, ensuring robust functionality and performance.

### **Prompts**

1. **KMM Unit Test**:
   - **Prompt**: “Create a JUnit test for a KMM TransactionRepository to verify transaction fetching and caching.”
   - **Expected Output**:

     ```kotlin
     @Test
     fun testTransactionFetch() = runTest {
         val repo = TransactionRepositoryImpl()
         val transactions = repo.fetchTransactions("account123")
         assertEquals(2, transactions.size)
         assertEquals("Groceries", transactions[0].description)
     }
     @Test
     fun testTransactionCache() = runTest {
         val repo = TransactionRepositoryImpl()
         val cache = CacheManager()
         cache.cacheTransactions(listOf(Transaction(id = "1", accountId = "account123", amount = 50.0, date = "2025-08-27", description = "Coffee")))
         val transactions = repo.fetchTransactions("account123") // Simulate network failure
         assertEquals(1, transactions.size)
     }
     ```

2. **SwiftUI Unit Test**:
   - **Prompt**: “Generate an XCTest case for a SwiftUI DashboardViewModel to verify net worth calculation.”
   - **Expected Output**:

     ```swift
     import XCTest
     class DashboardViewModelTests: XCTestCase {
         func testNetWorthCalculation() async {
             let viewModel = DashboardViewModel(repository: MockTransactionRepository())
             await viewModel.loadData()
             XCTAssertEqual(viewModel.netWorth, 150.0)
         }
     }
     class MockTransactionRepository: TransactionRepository {
         func fetchTransactions(accountId: String) async throws -> [Transaction] {
             return [Transaction(id: "1", accountId: "account123", amount: 100.0, date: "2025-08-27", description: "Groceries"),
                     Transaction(id: "2", accountId: "account123", amount: 50.0, date: "2025-08-27", description: "Coffee")]
         }
     }
     ```

3. **Debugging Prompt**:
   - **Prompt**: “Debug a SwiftUI view where the Chart view fails to animate on data update, ensuring accessibility support.”
   - **Expected Output**:

     ```swift
     struct DashboardView: View {
         @StateObject private var viewModel = DashboardViewModel()
         var body: some View {
             Chart {
                 ForEach(viewModel.spendingData) { data in
                     BarMark(x: .value("Category", data.category), y: .value("Amount", data.amount))
                         .foregroundStyle(.blue.gradient)
                 }
             }
             .frame(height: 200)
             .animation(.easeInOut(duration: 0.5), value: viewModel.spendingData) // Add explicit animation
             .accessibilityLabel("Spending by category chart")
             .task { await viewModel.loadData() }
         }
     }
     ```

4. **API Error Handling**:
   - **Prompt**: “Create a KMM function to handle Plaid API errors with a fallback to cached data.”
   - **Expected Output**:

     ```kotlin
     suspend fun fetchTransactionsWithFallback(accountId: String): List<Transaction> {
         return try {
             val transactions = PlaidClient.getTransactions(accountId)
             CacheManager.cacheTransactions(transactions)
             transactions
         } catch (e: Exception) {
             CacheManager.getCachedTransactions()
         }
     }
     ```

### **Usage Guidelines**

- **Windsurf**: Use Copilot for JUnit tests and KMM debugging.
- **Cursor**: Generate XCTest cases and debug SwiftUI issues.
- **Validation**: Run tests in Xcode and IntelliJ, validate with beta users via TestFlight.

## **Vibe-Coding Workflow**

### **Tools**

- **Windsurf**: IntelliJ-based IDE with KMM plugin and Copilot for Kotlin.
- **Cursor**: AI-driven IDE for SwiftUI and testing.
- **Figma + Magician/Builder.io**: Wireframing and SwiftUI export.
- **Xcode**: SwiftUI previews and TestFlight deployment.

### **Process**

1. **UI Design** (2–3 weeks):
   - Use Figma prompts to generate wireframes, export to SwiftUI via Builder.io.
   - Validate with 10–20 families.
2. **Frontend Development** (6–8 weeks):
   - Use Cursor prompts to generate SwiftUI views, integrating KMM logic.
   - Example: “Create a SwiftUI budget list with swipe actions.”
3. **Backend Development** (6–8 weeks):
   - Use Windsurf prompts for KMM repositories and API clients.
   - Example: “Generate a KMM repository for family account management.”
4. **Testing** (2–3 weeks):
   - Use prompts to generate JUnit/XCTest cases.
   - Debug issues with AI assistance in Cursor.

## **Success Criteria**

- **Code Quality**: 90%+ of generated code requires minimal refactoring.
- **Speed**: Prompts reduce coding time by 20–30%.
- **Usability**: Beta testers rate UI as “intuitive” (90%+ approval).
- **Integration**: All prompts align with KMM and SwiftUI stack.

## **Conclusion**

This System Prompts Document provides a comprehensive set of AI prompts to accelerate development of **FamilyBooks** using Windsurf, Cursor, and Figma. The prompts ensure rapid prototyping, high-quality code, and engaging UX, aligning with the app’s goals of financial management and kid education. By leveraging vibe-coding, the app will deliver a robust iOS MVP with scalability for Android.

*Word Count: ~2200*

```

---
