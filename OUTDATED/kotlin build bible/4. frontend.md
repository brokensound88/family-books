# Frontend Guidelines for FamilyBooks

## **Overview**

The **FamilyBooks** is an iOS-first mobile application designed to empower families to manage their finances, synchronize bank accounts, superannuation (with an Australian focus), savings, and investment accounts, educate children on saving and investing, and balance household budgets through a visually stunning, gamified interface. The frontend is built using **SwiftUI** for a native iOS experience, leveraging **Kotlin Multiplatform Mobile (KMM)** for shared business logic, with plans for future Android expansion using Jetpack Compose. Development will utilize **Windsurf** (IntelliJ-based IDE) and **Cursor** (AI-driven IDE) for vibe-coding, incorporating AI-assisted tools like GitHub Copilot and Figma plugins (Magician, Builder.io) to streamline UI design and code generation. This document provides comprehensive guidelines for designing, developing, and maintaining the frontend, ensuring a visually appealing, intuitive, and accessible interface optimized for families and kids (ages 8–18). The guidelines cover SwiftUI best practices, design principles, accessibility, and vibe-coding workflows, with considerations for future Android implementation.

## **Objectives**

- Deliver a visually stunning SwiftUI frontend for iOS, featuring vibrant animations, intuitive navigation, and kid-friendly gamification.
- Ensure seamless integration with KMM shared logic for data-driven UI components.
- Maintain accessibility and localization standards for broad usability.
- Leverage AI tools in Windsurf and Cursor to accelerate vibe-coding and prototyping.
- Design with scalability for future Android implementation using Jetpack Compose.
- Achieve a 4.5+ App Store rating through engaging, family-focused UX.

## **Frontend Scope**

### **MVP Frontend Features**

The iOS frontend, built with SwiftUI, includes the following screens and components:

1. **Dashboard**:
   - Displays net worth, spending trends, and financial health score with animated charts.
   - Quick access to budgets and kids’ savings goals.
2. **Budgeting Screen**:
   - Zero-based budgeting interface with customizable categories.
   - Transaction history with AI-driven categorization.
3. **Kids’ Education Module**:
   - Gamified views for savings jars, virtual stock portfolios, and financial lessons.
   - Parental oversight controls for goal setting and approvals.
4. **Investment Tracking**:
   - Visualizes portfolio and superannuation performance with interactive graphs.
5. **Family Collaboration**:
   - Role-based views for parents (admin) and kids (limited).
   - Shared goal tracking with notifications.
6. **Settings**:
   - Account management, theme customization, and notification preferences.

### **Future Frontend Features (Post-MVP)**

- Android UI with Jetpack Compose, mirroring SwiftUI designs.
- Additional kid education modules (e.g., advanced investing simulations).
- Apple Watch support for quick budget checks.

## **Design Principles**

### **Visual Style**

- **Vibrant Aesthetics**: Use bright, family-friendly colors (e.g., blues, greens, oranges) with gradients for a modern, engaging look.
- **SF Symbols**: Leverage Apple’s SF Symbols for intuitive icons (e.g., wallet for budgets, piggy bank for kids’ savings).
- **Animations**: Implement smooth SwiftUI animations (e.g., spring animations for cards, progress bars) to enhance engagement:

  ```swift
  struct BudgetCard: View {
      @State private var isTapped = false
      var body: some View {
          VStack {
              Image(systemName: "dollarsign.circle")
                  .font(.title)
              Text("Monthly Budget: $5,000")
                  .font(.headline)
          }
          .padding()
          .background(LinearGradient(colors: [.blue, .cyan], startPoint: .top, endPoint: .bottom))
          .cornerRadius(12)
          .scaleEffect(isTapped ? 1.05 : 1.0)
          .animation(.spring(response: 0.4, dampingFraction: 0.6), value: isTapped)
          .onTapGesture { isTapped.toggle() }
      }
  }
  ```

- **Consistency**: Adhere to iOS Human Interface Guidelines for typography, spacing, and navigation.

### **Accessibility**

- **VoiceOver**: Ensure all UI elements (e.g., charts, buttons) have descriptive labels:

  ```swift
  Text("Net Worth: $10,000")
      .accessibilityLabel("Current net worth is ten thousand dollars")
  ```

- **Dynamic Type**: Support scalable fonts with `DynamicTypeSize`:

  ```swift
  Text("Budget Overview")
      .font(.system(.title, design: .rounded))
      .dynamicTypeSize(.large)
  ```

- **High Contrast**: Provide high-contrast themes for visibility.
- **Localization**: Support English and Australian English, with currency formatting (e.g., AUD).

### **Gamification**

- **Kid-Friendly Elements**: Use animated progress bars, badges, and virtual rewards to engage kids:

  ```swift
  struct SavingsJarView: View {
      @StateObject private var viewModel = SavingsJarViewModel()
      var body: some View {
          VStack {
              Text(viewModel.goalName)
                  .font(.title2)
              ProgressView(value: viewModel.progress)
                  .progressViewStyle(.circular)
                  .tint(.green)
                  .scaleEffect(1.5)
                  .animation(.easeInOut(duration: 0.5), value: viewModel.progress)
          }
          .accessibilityLabel("Savings goal: \(viewModel.goalName), \(Int(viewModel.progress * 100))% complete")
      }
  }
  ```

- **Parental Feedback**: Visual cues (e.g., confetti animations) for approved kid actions.

## **SwiftUI Best Practices**

### **Architecture**

- **MVVM Pattern**: Use Model-View-ViewModel for separation of concerns, integrating with KMM data:

  ```swift
  class DashboardViewModel: ObservableObject {
      @Published var netWorth: Double = 0.0
      @Published var spendingData: [CategoryData] = []
      private let repository: TransactionRepository
      init(repository: TransactionRepository = TransactionRepositoryImpl()) {
          self.repository = repository
      }
      func loadData() async {
          let transactions = await repository.fetchTransactions(accountId: "user123")
          netWorth = transactions.reduce(0.0) { $0 + $1.amount }
          spendingData = transactions.groupByCategory()
      }
  }
  struct DashboardView: View {
      @StateObject private var viewModel = DashboardViewModel()
      var body: some View {
          NavigationStack {
              VStack {
                  Chart {
                      ForEach(viewModel.spendingData) { data in
                          BarMark(x: .value("Category", data.category), y: .value("Amount", data.amount))
                              .foregroundStyle(.blue.gradient)
                      }
                  }
                  .frame(height: 200)
                  Text("Net Worth: $\(viewModel.netWorth, specifier: "%.2f")")
                      .font(.title)
              }
              .navigationTitle("Family Wealth")
              .task { await viewModel.loadData() }
          }
      }
  }
  ```

- **Modular Components**: Create reusable SwiftUI views (e.g., `BudgetCard`, `GoalCard`) for consistency.
- **State Management**: Use `@State`, `@Binding`, and `@EnvironmentObject` for reactive UI updates.

### **Performance**

- **Lazy Loading**: Use `LazyVStack` for long lists (e.g., transaction history):

  ```swift
  ScrollView {
      LazyVStack {
          ForEach(viewModel.transactions) { transaction in
              TransactionRow(transaction: transaction)
          }
      }
  }
  ```

- **Async Data**: Load data asynchronously with `Task` and `async/await` for smooth UI:

  ```swift
  .task { await viewModel.loadData() }
  ```

- **Rendering Optimization**: Minimize view updates with `@StateObject` and `.equatable()` for data models.

### **Integration with KMM**

- **Expect/Actual Mechanism**: Consume KMM logic via Swift interfaces:

  ```swift
  import shared
  class DashboardViewModel: ObservableObject {
      private let repository: TransactionRepository
      init() {
          self.repository = TransactionRepositoryImpl()
      }
      func loadData() async {
          let transactions = try! await repository.fetchTransactions(accountId: "user123").toList()
          // Process transactions
      }
  }
  ```

- **Data Mapping**: Convert KMM data models to SwiftUI-compatible structs for UI binding.

## **Frontend Development Workflow**

### **Tools**

- **Windsurf**: IntelliJ-based IDE for KMM shared logic, with Copilot for Kotlin code completion.
- **Cursor**: AI-driven IDE for SwiftUI development, using prompts like:

  ```swift
  // Create a SwiftUI view for a kid’s savings goal with animated progress circle
  ```

- **Figma + Magician/Builder.io**: AI-generated wireframes exported to SwiftUI code.
- **Xcode**: Primary environment for SwiftUI debugging and testing.

### **Vibe-Coding Process**

1. **Wireframing** (2–3 weeks):
   - Use Figma with Magician to generate wireframes with prompts:
     - “iOS dashboard with colorful net worth chart and budget cards.”
     - “Kid education screen with animated savings jars.”
   - Export to SwiftUI via Builder.io:

     ```swift
     struct GoalCard: View {
         var goal: SavingsGoal
         var body: some View {
             VStack {
                 Text(goal.name)
                     .font(.headline)
                 Text("$\(goal.current, specifier: "%.2f") / $\(goal.target, specifier: "%.2f")")
                     .font(.subheadline)
             }
             .padding()
             .background(.yellow.gradient)
             .cornerRadius(10)
         }
     }
     ```

2. **Prototyping** (1–2 weeks):
   - Build clickable Figma prototypes for 5–7 screens.
   - Validate with 10–20 families for usability feedback.
3. **SwiftUI Development** (6–8 weeks):
   - Code screens in Cursor, using AI prompts for components:

     ```swift
     // Generate a SwiftUI chart for spending by category with vibrant colors
     ```

   - Integrate with KMM logic for data fetching:

     ```swift
     struct TransactionListView: View {
         @StateObject private var viewModel = TransactionViewModel()
         var body: some View {
             List(viewModel.transactions) { transaction in
                 Text("\(transaction.description): $\(transaction.amount, specifier: "%.2f")")
             }
             .task { await viewModel.loadTransactions() }
         }
     }
     ```

4. **Styling and Animation** (2–3 weeks):
   - Add gradients, SF Symbols, and animations:

     ```swift
     struct NetWorthView: View {
         @State private var isAnimating = false
         var netWorth: Double
         var body: some View {
             Text("Net Worth: $\(netWorth, specifier: "%.2f")")
                 .font(.title)
                 .rotationEffect(.degrees(isAnimating ? 360 : 0))
                 .animation(.easeInOut(duration: 1.0).repeatCount(1), value: isAnimating)
                 .onAppear { isAnimating = true }
         }
     }
     ```

5. **Testing** (2–3 weeks):
   - Use XCTest for UI testing:

     ```swift
     func testDashboardView() {
         let viewModel = DashboardViewModel()
         XCTAssertEqual(viewModel.netWorth, 0.0)
     }
     ```

   - Validate animations and accessibility in Xcode.

### **AI-Assisted Vibe-Coding**

- **Cursor**: Generate SwiftUI views and debug with prompts:

  ```swift
  // Fix a SwiftUI view to support dynamic type and VoiceOver
  ```

- **Windsurf**: Use Copilot for KMM integration:

  ```kotlin
  // Create a Kotlin function to fetch transactions and map to SwiftUI-compatible model
  ```

- **Figma Integration**: Export AI-generated wireframes to SwiftUI, refining in Cursor.

## **Accessibility Guidelines**

- **VoiceOver**: Add labels and hints:

  ```swift
  Button("Save Budget") {
      // Action
  }
  .accessibilityLabel("Save budget")
  .accessibilityHint("Saves the current budget configuration")
  ```

- **Dynamic Type**: Support all font sizes:

  ```swift
  Text("Category")
      .font(.system(.body, design: .rounded))
      .dynamicTypeSize(.xSmall ... .xxxLarge)
  ```

- **Color Contrast**: Ensure WCAG 2.1 compliance (4.5:1 ratio for text).
- **Haptic Feedback**: Add subtle haptics for interactions:

  ```swift
  import CoreHaptics
  func triggerHaptic() {
      let generator = UIImpactFeedbackGenerator(style: .medium)
      generator.impactOccurred()
  }
  ```

## **Localization**

- Support English and Australian English:

  ```swift
  Text("Budget")
      .environment(\.locale, Locale(identifier: "en_AU"))
  ```

- Format currencies for AUD:

  ```swift
  TextField("Amount", value: $amount, format: .currency(code: "AUD"))
  ```

## **Future Android Considerations**

- **Jetpack Compose Alignment**: Design SwiftUI with modular components to ease translation to Compose:

  ```kotlin
  @Composable
  fun BudgetCard(name: String, amount: Double) {
      Card(
          modifier = Modifier.fillMaxWidth(),
          colors = CardDefaults.cardColors(containerColor = Color.Cyan)
      ) {
          Column(modifier = Modifier.padding(16.dp)) {
              Text(name, style = MaterialTheme.typography.titleMedium)
              Text("$${amount}", style = MaterialTheme.typography.bodyLarge)
          }
      }
  }
  ```

- **Shared Assets**: Store colors, typography, and icons in Figma for consistency.
- **KMM Reuse**: Ensure KMM logic (e.g., `TransactionRepository`) is platform-agnostic.

## **Performance Optimization**

- **Image Handling**: Use SF Symbols or optimized PNGs to reduce app size.
- **View Updates**: Minimize redraws with `@Published` and `.equatable()`:

  ```swift
  struct CategoryData: Equatable {
      let category: String
      let amount: Double
  }
  ```

- **Async Image Loading**: Load remote images (e.g., bank logos) asynchronously:

  ```swift
  AsyncImage(url: URL(string: bank.logoUrl)) { image in
      image.resizable().scaledToFit()
  } placeholder: {
      ProgressView()
  }
  ```

## **Testing and Validation**

- **Unit Testing**: Test view models with XCTest:

  ```swift
  func testBudgetViewModel() {
      let viewModel = BudgetViewModel()
      viewModel.name = "Groceries"
      viewModel.amount = 500.0
      XCTAssertEqual(viewModel.name, "Groceries")
  }
  ```

- **UI Testing**: Validate navigation and interactions:

  ```swift
  func testNavigation() {
      let app = XCUIApplication()
      app.buttons["Budget"].tap()
      XCTAssertTrue(app.navigationBars["Budget Overview"].exists)
  }
  ```

- **User Testing**: Conduct beta testing via TestFlight with 50–100 families to validate UX.

## **Vibe-Coding Workflow**

- **Wireframing**:
  - Use Figma + Magician with prompts like “iOS dashboard with animated charts.”
  - Export to SwiftUI via Builder.io, refining in Cursor.
- **Development Sprints**:
  - Sprint 1: Dashboard with net worth chart.
  - Sprint 2: Budgeting screen with transaction list.
  - Sprint 3: Kids’ module with savings jar.
  - Use Cursor prompts for rapid iteration:

    ```swift
    // Create a SwiftUI view for a transaction list with swipe actions
    ```

- **Debugging**:
  - Use Cursor’s AI to fix UI issues (e.g., animation lag, accessibility errors).
  - Leverage Xcode’s SwiftUI preview for real-time testing.
- **Validation**:
  - Test prototypes with families to ensure kid engagement and parental usability.

## **Constraints**

- **iOS Version**: Support iOS 16.0+ to cover 90%+ of iPhone users.
- **Device Compatibility**: Optimize for iPhone and iPad, with adaptive layouts.
- **Performance**: Ensure animations run smoothly on mid-range devices (e.g., iPhone SE).

## **Dependencies**

- **Figma**: For wireframing and design export.
- **Builder.io**: For SwiftUI code generation.
- **KMM Shared Module**: Provides data for UI binding.
- **External APIs**: Plaid/Yodlee, FinanceKit for financial data.

## **Success Criteria**

- **Visual Appeal**: 90%+ of beta testers rate UI as “engaging” or “very engaging.”
- **Performance**: Screens load in <1 second, animations at 60 FPS.
- **Accessibility**: Full VoiceOver and dynamic type support.
- **User Satisfaction**: 4.5+ App Store rating post-launch.
- **Scalability**: UI components reusable for Jetpack Compose with minimal changes.

## **Conclusion**

These frontend guidelines ensure **FamilyBooks** delivers a visually stunning, intuitive, and accessible SwiftUI interface for iOS, integrated with KMM for scalable Android expansion. By leveraging vibe-coding in Windsurf and Cursor, with AI tools for design and code generation, the frontend will engage families and kids while meeting modern iOS standards. The guidelines provide a clear path for development, testing, and validation, setting the stage for a successful app launch.

*Word Count: ~1900*

```

---
